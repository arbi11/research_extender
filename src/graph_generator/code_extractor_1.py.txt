import tree_sitter_c_sharp as tscsharp
from tree_sitter import Language, Parser
from pathlib import Path
import json
from typing import List, Dict, Any, Optional
from pydantic import BaseModel, Field

# Load C# language
CS_LANGUAGE = Language(tscsharp.language())
parser = Parser(CS_LANGUAGE)

# Dynamic external dependency caches
EXTERNAL_DEPENDENCIES_CACHE = set()
INTERNAL_DEPENDENCIES_CACHE = set()

# Comprehensive query for namespace, classes, and interfaces
comprehensive_query = CS_LANGUAGE.query('''
(namespace_declaration
  name: [
    (identifier) @name.definition.namespace
    (qualified_name) @name.definition.namespace
  ]
  body: (declaration_list
    [
      (class_declaration
        name: (identifier) @name.definition.class
      ) @definition.class

      (interface_declaration
        name: (identifier) @name.definition.interface
      ) @definition.interface
    ]
  )
) @definition.namespace

(class_declaration
  name: (identifier) @name.definition.class
  body: (declaration_list
    [
      (method_declaration
        name: (identifier) @name.definition.method
        parameters: (parameter_list
          (parameter
            name: (identifier) @name.definition.parameter
          )
        )?
      ) @definition.method
      
      (field_declaration
        (variable_declaration
          type: (_) @type.definition.field
          (variable_declarator
            (identifier) @name.definition.field
          )
        )
      ) @definition.field
      
      (property_declaration
        name: (identifier) @name.definition.property
      ) @definition.property
    ]
  )
) @definition.class

(interface_declaration
  name: (identifier) @name.definition.interface
  body: (declaration_list
    [
      (method_declaration
        name: (identifier) @name.definition.method
        parameters: (parameter_list
          (parameter
            name: (identifier) @name.definition.parameter
          )
        )?
      ) @definition.method
      
      (property_declaration
        name: (identifier) @name.definition.property
      ) @definition.property
    ]
  )
) @definition.interface
''')

# Query to capture method details
method_query = CS_LANGUAGE.query('''
(method_declaration
  name: (identifier) @name.definition.method
  parameters: (parameter_list
    (parameter
      type: (_) @type.definition.parameter
      name: (identifier) @name.definition.parameter
    )
  )?
  body: (block
    (comment) @comment.method
  )*
) @definition.method @expression.method_declaration
''')

# Query for references: using directives and method calls with enhanced context
references_query = CS_LANGUAGE.query('''
(using_directive
  name: [
    (identifier) @name.reference.using
    (qualified_name) @name.reference.using
  ]
) @reference.using

(invocation_expression
  function: [
    (identifier) @name.reference.method_call
    (member_access_expression
      expression: (_) @expression.reference.method_target
      name: (identifier) @name.reference.method_call
    ) @member_access.reference.method_call
  ]
) @reference.method_call

(object_creation_expression
  type: [
    (identifier) @name.reference.constructor_call
    (qualified_name) @name.reference.constructor_call
  ]
) @reference.constructor_call

(variable_declaration
  type: [
    (identifier) @type.reference.variable_type
    (qualified_name) @type.reference.variable_type
  ]
  (variable_declarator
    (identifier) @name.reference.variable_name
  )
) @reference.variable_declaration

(local_declaration_statement
  (variable_declaration
    [
      (implicit_type) @type.reference.implicit_type
      (predefined_type) @type.reference.explicit_type
      (identifier) @type.reference.explicit_type
      (qualified_name) @type.reference.explicit_type
    ]
    (variable_declarator
      (identifier) @name.reference.local_variable_name
      "="
      (object_creation_expression
        [
          (identifier) @type.reference.assigned_type
          (qualified_name) @type.reference.assigned_type
        ]
      )
    )
  )
) @reference.local_variable_assignment
''')

# Separate query to capture all local variables anywhere within methods
local_variables_query = CS_LANGUAGE.query('''
(local_declaration_statement
  (variable_declaration
    type: (_) @type.definition.local_variable
    (variable_declarator
      (identifier) @name.definition.local_variable
    )
  )
)

(assignment_expression
  left: (identifier) @name.definition.assigned_variable
)

(return_statement
  (_) @expression.return
)
''')

def extract_namespace_symbols(tree, file_path):
    """Extract namespace symbols with their contained classes and interfaces"""
    captures = comprehensive_query.captures(tree.root_node)
    symbols = []
    
    # Extract namespace symbols
    for namespace_node in captures.get('definition.namespace', []):
        namespace_name_nodes = [n for n in captures.get('name.definition.namespace', [])
                              if namespace_node.start_point <= n.start_point <= namespace_node.end_point]
        
        if not namespace_name_nodes:
            continue
            
        namespace_name = namespace_name_nodes[0].text.decode('utf8')
        
        # Get classes in this namespace
        namespace_classes = []
        for class_node in captures.get('definition.class', []):
            if namespace_node.start_point <= class_node.start_point <= namespace_node.end_point:
                class_name_nodes = [n for n in captures.get('name.definition.class', [])
                                  if class_node.start_point <= n.start_point <= class_node.end_point]
                if class_name_nodes:
                    namespace_classes.append(class_name_nodes[0].text.decode('utf8'))
        
        # Get interfaces in this namespace
        namespace_interfaces = []
        for interface_node in captures.get('definition.interface', []):
            if namespace_node.start_point <= interface_node.start_point <= namespace_node.end_point:
                interface_name_nodes = [n for n in captures.get('name.definition.interface', [])
                                      if interface_node.start_point <= n.start_point <= interface_node.end_point]
                if interface_name_nodes:
                    namespace_interfaces.append(interface_name_nodes[0].text.decode('utf8'))
        
        symbol = {
            "name": namespace_name,
            "type": "namespaces",
            "category": "definition",
            "start_line": namespace_node.start_point[0] + 1,
            "end_line": namespace_node.end_point[0] + 1,
            "start_col": namespace_node.start_point[1],
            "end_col": namespace_node.end_point[1],
            "file_path": file_path,
            "capture_name": "name.definition.namespace",
            "code": namespace_name,
            "classes": list(set(namespace_classes)),
            "interfaces": list(set(namespace_interfaces))
        }
        
        symbols.append(symbol)
    
    return symbols

def extract_class_symbols(tree, file_path):
    """Extract class symbols with methods, fields, and properties"""
    captures = comprehensive_query.captures(tree.root_node)
    symbols = []
    
    # Group captures by class
    for class_node in captures.get('definition.class', []):
        class_name_nodes = [n for n in captures.get('name.definition.class', []) 
                           if class_node.start_point <= n.start_point <= class_node.end_point]
        
        if not class_name_nodes:
            continue
            
        class_name = class_name_nodes[0].text.decode('utf8')
        
        # Get methods in this class
        methods = []
        for method_node in captures.get('definition.method', []):
            if class_node.start_point <= method_node.start_point <= class_node.end_point:
                method_name_nodes = [n for n in captures.get('name.definition.method', [])
                                   if method_node.start_point <= n.start_point <= method_node.end_point]
                if method_name_nodes:
                    method_name = method_name_nodes[0].text.decode('utf8')
                    methods.append(method_name)
        
        # Get class-level fields with types (avoiding duplicates)
        class_fields = {}
        field_name_nodes = captures.get('name.definition.field', [])
        field_type_nodes = captures.get('type.definition.field', [])
        
        for field_node in field_name_nodes:
            if class_node.start_point <= field_node.start_point <= class_node.end_point:
                # Make sure it's not inside any method
                is_in_method = any(
                    method_node.start_point <= field_node.start_point <= method_node.end_point
                    for method_node in captures.get('definition.method', [])
                    if class_node.start_point <= method_node.start_point <= class_node.end_point
                )
                if not is_in_method:
                    field_name = field_node.text.decode('utf8')
                    # Find the corresponding type for this field
                    field_type = "unknown"
                    for type_node in field_type_nodes:
                        # Check if this type node is associated with this field (within same field declaration)
                        if (type_node.start_point[0] == field_node.start_point[0] or 
                            abs(type_node.start_point[0] - field_node.start_point[0]) <= 2):
                            field_type = type_node.text.decode('utf8')
                            break
                    
                    # Only add if not already present (avoids duplicates)
                    if field_name not in class_fields:
                        class_fields[field_name] = field_type
        
        # Get properties
        properties = []
        for prop_node in captures.get('name.definition.property', []):
            if class_node.start_point <= prop_node.start_point <= class_node.end_point:
                properties.append(prop_node.text.decode('utf8'))
        
        # Create enhanced symbol
        symbol = {
            "name": class_name,
            "type": "classes", 
            "category": "definition",
            "start_line": class_node.start_point[0] + 1,
            "end_line": class_node.end_point[0] + 1,
            "start_col": class_node.start_point[1],
            "end_col": class_node.end_point[1],
            "file_path": file_path,
            "capture_name": "name.definition.class",
            "code": class_name,
            "methods": methods,
            "fields": class_fields,
            "properties": list(set(properties))
        }
        
        symbols.append(symbol)
    
    return symbols

def extract_interface_symbols(tree, file_path):
    """Extract interface symbols with methods and properties"""
    captures = comprehensive_query.captures(tree.root_node)
    symbols = []
    
    for interface_node in captures.get('definition.interface', []):
        interface_name_nodes = [n for n in captures.get('name.definition.interface', [])
                              if interface_node.start_point <= n.start_point <= interface_node.end_point]
        
        if not interface_name_nodes:
            continue
            
        interface_name = interface_name_nodes[0].text.decode('utf8')
        
        # Get methods in this interface
        methods = []
        for method_node in captures.get('definition.method', []):
            if interface_node.start_point <= method_node.start_point <= interface_node.end_point:
                method_name_nodes = [n for n in captures.get('name.definition.method', [])
                                   if method_node.start_point <= n.start_point <= method_node.end_point]
                if method_name_nodes:
                    method_name = method_name_nodes[0].text.decode('utf8')
                    methods.append(method_name)
        
        # Get properties in this interface
        properties = []
        for prop_node in captures.get('name.definition.property', []):
            if interface_node.start_point <= prop_node.start_point <= interface_node.end_point:
                properties.append(prop_node.text.decode('utf8'))
        
        symbol = {
            "name": interface_name,
            "type": "interfaces",
            "category": "definition",
            "start_line": interface_node.start_point[0] + 1,
            "end_line": interface_node.end_point[0] + 1,
            "start_col": interface_node.start_point[1],
            "end_col": interface_node.end_point[1],
            "file_path": file_path,
            "capture_name": "name.definition.interface",
            "code": interface_name,
            "methods": methods,
            "properties": list(set(properties))
        }
        
        symbols.append(symbol)
    
    return symbols

def is_external_dependency_dynamic(target_class: str, file_path: str) -> bool:
    """Dynamically determine if a target class is an external dependency by checking file existence"""
    global EXTERNAL_DEPENDENCIES_CACHE, INTERNAL_DEPENDENCIES_CACHE

    # Check caches first
    if target_class in EXTERNAL_DEPENDENCIES_CACHE:
        return True
    if target_class in INTERNAL_DEPENDENCIES_CACHE:
        return False

    # Split target_class to get namespace parts
    parts = target_class.split('.')

    # Check for well-known external namespaces first
    if parts[0] in ['System', 'Microsoft', 'Console', 'Math', 'String', 'DateTime', 'Convert']:
        EXTERNAL_DEPENDENCIES_CACHE.add(target_class)
        return True

    # Get the repository root (parent of current working directory)
    current_file_path = Path(file_path)
    repo_root = current_file_path.parent
    while repo_root.parent != repo_root:  # Stop at filesystem root
        if (repo_root / '.git').exists() or len(list(repo_root.glob('*.cs'))) > 0:
            break
        repo_root = repo_root.parent

    # Check if any C# file contains a class definition with this target_class name
    # Look for files that might contain this class
    class_name = parts[-1]  # Last part is usually the class name
    namespace_name = '.'.join(parts[:-1]) if len(parts) > 1 else None

    found_internal = False
    for cs_file in repo_root.rglob('*.cs'):
        try:
            with open(cs_file, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
                # Simple check for class definition
                if f'class {class_name}' in content:
                    # If namespace specified, check if it matches
                    if namespace_name:
                        if f'namespace {namespace_name}' in content:
                            found_internal = True
                            break
                    else:
                        found_internal = True
                        break
        except:
            continue

    # Cache the result
    if found_internal:
        INTERNAL_DEPENDENCIES_CACHE.add(target_class)
        return False
    else:
        EXTERNAL_DEPENDENCIES_CACHE.add(target_class)
        return True

def extract_reference_symbols(tree, file_path):
    """Extract reference symbols: using directives, method calls, constructor calls with target resolution"""
    captures = references_query.captures(tree.root_node)
    references = []

    # Build variable type mapping for target class resolution
    variable_types = build_variable_type_map(captures)

    # Build calling context mapping (line -> method/class info)
    calling_contexts = build_calling_context_map(tree.root_node, file_path)

    # Extract using directive references
    for using_node in captures.get('reference.using', []):
        using_name_nodes = [n for n in captures.get('name.reference.using', [])
                           if using_node.start_point <= n.start_point <= using_node.end_point]

        if using_name_nodes:
            using_name = using_name_nodes[0].text.decode('utf8')

            reference = {
                "name": using_name,
                "type": "using_directives",
                "category": "reference",
                "start_line": using_node.start_point[0] + 1,
                "end_line": using_node.end_point[0] + 1,
                "start_col": using_node.start_point[1],
                "end_col": using_node.end_point[1],
                "file_path": file_path,
                "capture_name": "reference.using",
                "code": using_name,
                "context_code": using_node.text.decode('utf8')
            }
            references.append(reference)

    # Extract method call references with target class resolution
    for call_node in captures.get('reference.method_call', []):
        call_name_nodes = [n for n in captures.get('name.reference.method_call', [])
                          if call_node.start_point <= n.start_point <= call_node.end_point]

        if call_name_nodes:
            # Take the last name node (the actual method name in member access)
            call_name = call_name_nodes[-1].text.decode('utf8')

            # Try to resolve target class
            target_class = resolve_target_class_for_method_call(call_node, captures, variable_types)

            # Skip external dependencies during AST creation
            if target_class and is_external_dependency_dynamic(target_class, file_path):
                continue

            # Get calling context
            call_line = call_node.start_point[0] + 1
            calling_context = calling_contexts.get(call_line, {})

            reference = {
                "name": call_name,
                "type": "method_calls",
                "category": "reference",
                "start_line": call_line,
                "end_line": call_node.end_point[0] + 1,
                "start_col": call_node.start_point[1],
                "end_col": call_node.end_point[1],
                "file_path": file_path,
                "capture_name": "reference.method_call",
                "code": call_name,
                "context_code": call_node.text.decode('utf8'),
                "target_class": target_class,  # Enhanced context
                "calling_entity": calling_context.get('calling_entity')  # NEW: Hierarchical calling context
            }
            references.append(reference)

    # Extract constructor call references
    for constructor_node in captures.get('reference.constructor_call', []):
        constructor_name_nodes = [n for n in captures.get('name.reference.constructor_call', [])
                                 if constructor_node.start_point <= n.start_point <= constructor_node.end_point]

        if constructor_name_nodes:
            constructor_name = constructor_name_nodes[0].text.decode('utf8')

            # Skip external dependencies during AST creation
            if is_external_dependency_dynamic(constructor_name, file_path):
                continue

            # Get calling context
            constructor_line = constructor_node.start_point[0] + 1
            calling_context = calling_contexts.get(constructor_line, {})

            reference = {
                "name": constructor_name,
                "type": "constructor_calls",
                "category": "reference",
                "start_line": constructor_line,
                "end_line": constructor_node.end_point[0] + 1,
                "start_col": constructor_node.start_point[1],
                "end_col": constructor_node.end_point[1],
                "file_path": file_path,
                "capture_name": "reference.constructor_call",
                "code": constructor_name,
                "context_code": constructor_node.text.decode('utf8'),
                "target_class": constructor_name,  # Constructor calls already have the class name
                "calling_entity": calling_context.get('calling_entity')  # NEW: Hierarchical calling context
            }
            references.append(reference)

    return references

def build_variable_type_map(captures):
    """Build a mapping of variable names to their declared types"""
    variable_types = {}

    # Process regular variable declarations
    for var_decl_node in captures.get('reference.variable_declaration', []):
        var_name_nodes = [n for n in captures.get('name.reference.variable_name', [])
                         if var_decl_node.start_point <= n.start_point <= var_decl_node.end_point]
        var_type_nodes = [n for n in captures.get('type.reference.variable_type', [])
                         if var_decl_node.start_point <= n.start_point <= var_decl_node.end_point]

        if var_name_nodes and var_type_nodes:
            var_name = var_name_nodes[0].text.decode('utf8')
            var_type = var_type_nodes[0].text.decode('utf8')
            # Only use explicit types, skip "var"
            if var_type != 'var':
                variable_types[var_name] = var_type

    # Process local variable assignments with "var" and object creation
    for local_assign_node in captures.get('reference.local_variable_assignment', []):
        var_name_nodes = [n for n in captures.get('name.reference.local_variable_name', [])
                         if local_assign_node.start_point <= n.start_point <= local_assign_node.end_point]

        # Check for assigned type (from object creation)
        var_assigned_type_nodes = [n for n in captures.get('type.reference.assigned_type', [])
                                  if local_assign_node.start_point <= n.start_point <= local_assign_node.end_point]

        # Check for explicit types (non-var declarations)
        var_explicit_type_nodes = [n for n in captures.get('type.reference.explicit_type', [])
                                  if local_assign_node.start_point <= n.start_point <= local_assign_node.end_point]

        if var_name_nodes:
            var_name = var_name_nodes[0].text.decode('utf8')

            # Priority: Use assigned type (for var declarations), then explicit type
            if var_assigned_type_nodes:
                var_type = var_assigned_type_nodes[0].text.decode('utf8')
                variable_types[var_name] = var_type
            elif var_explicit_type_nodes:
                var_type = var_explicit_type_nodes[0].text.decode('utf8')
                variable_types[var_name] = var_type

    return variable_types

def build_calling_context_map(root_node, file_path):
    """Build a mapping of line numbers to hierarchical calling entity context"""
    calling_contexts = {}
    file_name = Path(file_path).stem

    def traverse_node(node, current_namespace=None, current_class=None, current_method=None):
        # Update context based on node type
        if node.type == 'namespace_declaration':
            # Find namespace name
            for child in node.children:
                if child.type == 'identifier' or child.type == 'qualified_name':
                    current_namespace = child.text.decode('utf8')
                    break
        elif node.type == 'class_declaration':
            # Find class name
            for child in node.children:
                if child.type == 'identifier':
                    current_class = child.text.decode('utf8')
                    break
        elif node.type == 'method_declaration':
            # Find method name
            for child in node.children:
                if child.type == 'identifier':
                    current_method = child.text.decode('utf8')
                    break

        # Store hierarchical calling entity for all lines covered by this node
        if current_class and current_method:
            start_line = node.start_point[0] + 1
            end_line = node.end_point[0] + 1

            # Build hierarchical calling entity name
            if current_namespace:
                calling_entity = f"{file_name}::{current_namespace}::{current_class}::{current_method}"
            else:
                calling_entity = f"{file_name}::{current_class}::{current_method}"

            for line in range(start_line, end_line + 1):
                calling_contexts[line] = {
                    'calling_entity': calling_entity
                }

        # Recursively traverse children
        for child in node.children:
            traverse_node(child, current_namespace, current_class, current_method)

    traverse_node(root_node)
    return calling_contexts

def resolve_target_class_for_method_call(call_node, captures, variable_types):
    """Resolve the target class for a method call"""
    try:
        # Find member access expressions for this call
        member_access_nodes = [n for n in captures.get('member_access.reference.method_call', [])
                              if call_node.start_point <= n.start_point <= call_node.end_point]

        if member_access_nodes:
            # Find the target expression (the object being called)
            target_expr_nodes = [n for n in captures.get('expression.reference.method_target', [])
                               if member_access_nodes[0].start_point <= n.start_point <= member_access_nodes[0].end_point]

            if target_expr_nodes:
                target_var = target_expr_nodes[0].text.decode('utf8')

                # Look up the variable type
                if target_var in variable_types:
                    return variable_types[target_var]

                # If it's already a qualified name (like Console.WriteLine), extract the class
                if '.' in target_var:
                    return target_var.split('.')[0]

        # Fallback: try to extract from context
        context = call_node.text.decode('utf8')
        if '.' in context:
            # Extract the part before the method call
            parts = context.split('.')
            if len(parts) >= 2:
                return parts[0].strip()

    except Exception as e:
        # If anything fails, return None - we'll handle this gracefully
        pass

    return None

def extract_method_symbols(tree, file_path):
    """Extract method symbols with parameters, local variables, and return information"""
    captures = method_query.captures(tree.root_node)
    local_var_captures = local_variables_query.captures(tree.root_node)
    symbols = []
    
    method_nodes = captures.get('definition.method', [])
    method_declaration_expressions = captures.get('expression.method_declaration', [])
    
    for method_node in method_nodes:
        # Get method name
        method_name_nodes = [n for n in captures.get('name.definition.method', [])
                           if method_node.start_point <= n.start_point <= method_node.end_point]
        
        if not method_name_nodes:
            continue
            
        method_name = method_name_nodes[0].text.decode('utf8')
        
        # Get parameters for this method with types (avoiding duplicates)
        parameters = {}
        param_name_nodes = captures.get('name.definition.parameter', [])
        param_type_nodes = captures.get('type.definition.parameter', [])
        
        for param_node in param_name_nodes:
            if method_node.start_point <= param_node.start_point <= method_node.end_point:
                param_name = param_node.text.decode('utf8')
                # Find the corresponding type for this parameter
                param_type = "unknown"
                for type_node in param_type_nodes:
                    # Check if this type node is associated with this parameter (same line or very close)
                    if (type_node.start_point[0] == param_node.start_point[0] or 
                        abs(type_node.start_point[0] - param_node.start_point[0]) <= 1):
                        param_type = type_node.text.decode('utf8')
                        break
                
                # Only add if not already present (avoids duplicates)
                if param_name not in parameters:
                    parameters[param_name] = param_type
        
        # Get local variables for this method with types (avoiding duplicates)
        local_variables = {}
        var_name_nodes = local_var_captures.get('name.definition.local_variable', [])
        var_type_nodes = local_var_captures.get('type.definition.local_variable', [])
        
        for var_node in var_name_nodes:
            if method_node.start_point <= var_node.start_point <= method_node.end_point:
                var_name = var_node.text.decode('utf8')
                # Find the corresponding type for this local variable
                var_type = "unknown"
                for type_node in var_type_nodes:
                    # Check if this type node is associated with this variable (same line or very close)
                    if (type_node.start_point[0] == var_node.start_point[0] or 
                        abs(type_node.start_point[0] - var_node.start_point[0]) <= 1):
                        var_type = type_node.text.decode('utf8')
                        break
                
                # Only add if not already present (avoids duplicates)
                if var_name not in local_variables:
                    local_variables[var_name] = var_type
        
        # Get assigned variables within this method (like iBenchmarkRate = 7)
        assigned_var_nodes = local_var_captures.get('name.definition.assigned_variable', [])
        
        for assigned_var_node in assigned_var_nodes:
            if method_node.start_point <= assigned_var_node.start_point <= method_node.end_point:
                var_name = assigned_var_node.text.decode('utf8')
                # Only add if not already captured and not a parameter
                if var_name not in local_variables and var_name not in parameters:
                    # Since assignment expressions don't contain type info, 
                    # we can't determine the type here - it would be in the original declaration
                    local_variables[var_name] = "unknown"
        
        # Get return statements for this method
        return_expressions = []
        for return_node in local_var_captures.get('expression.return', []):
            if method_node.start_point <= return_node.start_point <= method_node.end_point:
                return_expressions.append(return_node.text.decode('utf8'))
        
        # Get comments within this method
        comments = []
        for comment_node in captures.get('comment.method', []):
            if method_node.start_point <= comment_node.start_point <= method_node.end_point:
                comments.append(comment_node.text.decode('utf8'))
        
        # Find the corresponding method declaration expression
        method_declaration_expression = None
        for expr_node in method_declaration_expressions:
            if (expr_node.start_point == method_node.start_point and 
                expr_node.end_point == method_node.end_point):
                # Extract just the method signature (before the opening brace)
                full_text = expr_node.text.decode('utf8')
                # Find the opening brace to get just the signature
                brace_index = full_text.find('{')
                if brace_index != -1:
                    method_declaration_expression = full_text[:brace_index].strip()
                else:
                    method_declaration_expression = full_text
                break
        
        # Determine return type from method signature
        return_type = "void"  # default
        try:
            # Look for return type in method declaration
            type_nodes = [child for child in method_node.children if child.type in ['predefined_type', 'identifier', 'generic_name']]
            if type_nodes:
                return_type = type_nodes[0].text.decode('utf8')
        except:
            pass
        
        # Create method symbol
        symbol = {
            "name": method_name,
            "type": "methods",
            "category": "definition",
            "start_line": method_node.start_point[0] + 1,
            "end_line": method_node.end_point[0] + 1,
            "start_col": method_node.start_point[1],
            "end_col": method_node.end_point[1],
            "file_path": file_path,
            "capture_name": "name.definition.method",
            "code": method_name,
            "parameters": parameters,
            "local_variables": local_variables,
            "return_type": return_type,
            "return_expressions": return_expressions,
            "comments": comments,
            "expression": method_declaration_expression if method_declaration_expression else method_name
        }
        
        symbols.append(symbol)
    
    return symbols

def extract_all_symbols(code, file_path):
    """Extract all symbols: definitions and references with hierarchical names"""
    tree = parser.parse(bytes(code, "utf8"))

    # Get file name without extension for hierarchical naming
    file_name = Path(file_path).stem

    # Extract definitions with hierarchical names
    definitions = []
    namespace_symbols = extract_namespace_symbols(tree, file_path)
    class_symbols = extract_class_symbols(tree, file_path)
    interface_symbols = extract_interface_symbols(tree, file_path)
    method_symbols = extract_method_symbols(tree, file_path)

    # Build hierarchical names for definitions
    # Store original names before modification
    original_namespace_names = {id(ns): ns['name'] for ns in namespace_symbols}
    original_class_names = {id(cls): cls['name'] for cls in class_symbols}

    # Process namespaces first
    for symbol in namespace_symbols:
        symbol['name'] = f"{file_name}::{symbol['name']}"
    definitions.extend(namespace_symbols)

    # Process classes
    for symbol in class_symbols:
        original_name = original_class_names[id(symbol)]
        # Find parent namespace using original names
        parent_ns = None
        for ns in namespace_symbols:
            if ns['start_line'] <= symbol['start_line'] <= ns['end_line']:
                parent_ns = original_namespace_names[id(ns)]
                break

        if parent_ns:
            symbol['name'] = f"{file_name}::{parent_ns}::{original_name}"
        else:
            symbol['name'] = f"{file_name}::{original_name}"
    definitions.extend(class_symbols)

    # Process interfaces
    for symbol in interface_symbols:
        original_name = symbol['name']
        # Find parent namespace using original names
        parent_ns = None
        for ns in namespace_symbols:
            if ns['start_line'] <= symbol['start_line'] <= ns['end_line']:
                parent_ns = original_namespace_names[id(ns)]
                break

        if parent_ns:
            symbol['name'] = f"{file_name}::{parent_ns}::{original_name}"
        else:
            symbol['name'] = f"{file_name}::{original_name}"
    definitions.extend(interface_symbols)

    # Process methods
    for symbol in method_symbols:
        original_name = symbol['name']
        # Find parent class using original names
        parent_class = None
        parent_ns = None

        for cls in class_symbols:
            if cls['start_line'] <= symbol['start_line'] <= cls['end_line']:
                parent_class = original_class_names[id(cls)]
                # Find namespace for this class
                for ns in namespace_symbols:
                    if ns['start_line'] <= cls['start_line'] <= ns['end_line']:
                        parent_ns = original_namespace_names[id(ns)]
                        break
                break

        if parent_class and parent_ns:
            symbol['name'] = f"{file_name}::{parent_ns}::{parent_class}::{original_name}"
        elif parent_class:
            symbol['name'] = f"{file_name}::{parent_class}::{original_name}"
        else:
            symbol['name'] = f"{file_name}::{original_name}"
    definitions.extend(method_symbols)

    # Extract references with target-based names
    references = extract_reference_symbols(tree, file_path)

    # Modify reference names to use full hierarchical names
    for symbol in references:
        if symbol['type'] == 'method_calls' and 'target_class' in symbol:
            target_class = symbol['target_class']
            method_name = symbol['name']

            # Find the full hierarchical name for this target class + method
            full_target_name = None
            if target_class:  # Check if target_class is not None
                for def_symbol in definitions:
                    if def_symbol['type'] == 'methods' and def_symbol['name'].endswith(f"::{method_name}"):
                        # Check if this method belongs to the target class
                        name_parts = def_symbol['name'].split('::')
                        if len(name_parts) >= 4:  # file::namespace::class::method
                            class_part = name_parts[-2]  # class name
                            if class_part == target_class.split('.')[-1]:  # Handle qualified names
                                full_target_name = def_symbol['name']
                                break

            if full_target_name:
                symbol['name'] = full_target_name
            elif target_class:
                symbol['name'] = f"{target_class}::{method_name}"
            else:
                symbol['name'] = method_name  # Keep original name if no target class

        elif symbol['type'] == 'constructor_calls' and 'target_class' in symbol:
            target_class = symbol['target_class']

            # Find the full hierarchical name for this target class
            full_target_name = None
            if target_class:  # Check if target_class is not None
                for def_symbol in definitions:
                    if def_symbol['type'] == 'classes':
                        name_parts = def_symbol['name'].split('::')
                        if len(name_parts) >= 3:  # file::namespace::class
                            class_part = name_parts[-1]  # class name
                            if class_part == target_class.split('.')[-1]:  # Handle qualified names
                                full_target_name = def_symbol['name']
                                break

            if full_target_name:
                symbol['name'] = full_target_name
            elif target_class:
                symbol['name'] = target_class
            # If target_class is None, keep the original symbol name

    # Structure the result
    result = {
        "definitions": definitions,
        "references": references
    }

    return result

def extract_symbols_from_file(file_path):
    """Extract symbols from a C# file"""
    with open(file_path, "r", encoding="utf-8") as f:
        code = f.read()
    
    return extract_all_symbols(code, file_path)

class Symbol(BaseModel):
    """Represents a code symbol extracted from AST"""
    name: str = Field(..., description="Symbol name")
    symbol_type: str = Field(..., description="Type of symbol (class, method, field, etc.)")
    start_line: int = Field(..., description="Starting line number")
    end_line: int = Field(..., description="Ending line number")
    start_col: int = Field(..., description="Starting column")
    end_col: int = Field(..., description="Ending column")
    file_path: str = Field(..., description="File path")
    code: str = Field(..., description="Symbol code/name")
    metadata: Optional[Dict[str, Any]] = Field(None, description="Additional metadata")

class ASTExtractionResult(BaseModel):
    """Result of AST extraction"""
    success: bool = Field(..., description="Whether extraction succeeded")
    symbols: List[Symbol] = Field(default_factory=list, description="Extracted symbols")
    error: Optional[str] = Field(None, description="Error message if extraction failed")
    file_path: str = Field(..., description="File path that was processed")

class CSharpASTExtractor:
    """C# AST extractor using tree-sitter"""
    
    def __init__(self):
        self.language = CS_LANGUAGE
        self.parser = parser
    
    def extract_ast(self, file_path: str) -> ASTExtractionResult:
        """Extract AST symbols from a C# file"""
        try:
            # Extract symbols using existing functions
            result = extract_symbols_from_file(file_path)
            
            # Convert to Symbol objects
            symbols = []
            for definition in result.get("definitions", []):
                symbol = Symbol(
                    name=definition["name"],
                    symbol_type=definition["type"],
                    start_line=definition["start_line"],
                    end_line=definition["end_line"],
                    start_col=definition["start_col"],
                    end_col=definition["end_col"],
                    file_path=definition["file_path"],
                    code=definition["code"],
                    metadata={
                        "category": definition.get("category"),
                        "capture_name": definition.get("capture_name"),
                        **{k: v for k, v in definition.items()
                           if k not in ["name", "type", "start_line", "end_line",
                                      "start_col", "end_col", "file_path", "code",
                                      "category", "capture_name"]}
                    }
                )
                symbols.append(symbol)
            
            return ASTExtractionResult(
                success=True,
                symbols=symbols,
                file_path=file_path
            )
            
        except Exception as e:
            return ASTExtractionResult(
                success=False,
                symbols=[],
                error=str(e),
                file_path=file_path
            )
    
    def extract_symbols_dict(self, file_path: str) -> Dict[str, Any]:
        """Extract symbols and return as dictionary (legacy format)"""
        return extract_symbols_from_file(file_path)